分支管理
    分支就是科幻电影里面的平行宇宙,当你正在电脑前努力学习Git的时候,另一个你正在另一个平行宇宙里努力学习SVN.
    如果两个平行宇宙互不干扰,那对现在的你也没啥影响,不过,在某个时间点,两个平行宇宙合并了,结果,你既学会了Git又学会了SVN
    分支在实际中有什么用呢?假设你准备开发一个新功能,但是需要两周才能完成,第一周你写了50%的代码,如果立刻提交,由于代码还没写完,并不完整的代码库会导致别人不能干活了,如果等待吗全部写完再一次性提交,又存在丢失每天进度的巨大风险.
    现在有了分支,就不用怕了.你创建了一个属于你自己的分支,别人看不到,还继续在原来的分支上正常工作,而你在自己的分支上干活,想提交就提交,直到开发完毕后,再一次行合并到原来的分支上,这样,既安全,又不影响别人工作.
    其他版本控制系统如SVN等都有分支管理,但是用过之后你会发现,这些版本控制系统创建和切换分支比蜗牛还慢,简直让人无法忍受,结果分支功能成了摆设,大家都不去用
    但Git分支时与众不同的,无论创建、切换和删除分支,Git在1秒钟之内都能完成!无论你的版本库是1个文件还是1万个文件

创建与合并分支
    每次提交,Git都把他们串成一条时间线,这条时间线就是一个分支,截止到目前,只有一条时间线,在Git里,这个分支叫做主分支,即master分支.
    HEAD延更来说不是指向提交,而是指向master,master才是指向提交的,所以,HEAD指向的就是当前分支

    一开始的时候,master分支时一条线,Git用master指向最新的提交,再用HEAD指向master,就能确定当前分支,以及当前分支的提交点:

          HEAD
           ↓
         master
           ↓
    O——————O

    每次提交,master分支都会向前移动一步,这样,随着你不断提交,master分支的线也越来越长

                 HEAD
                  ↓
                master
                  ↓
    O——————O——————O

    当我们创建新的分支,例如dev时,Git新建了一个指针叫dev,指向master相同的提交,再把HEAD指向dev,就表示当前分支在dev上:
                 
                master
                  ↓
    O——————O——————O
                  ↑
                 dev
                  ↑
                 HEAD
    
    Git创建一个分支很快,因为除了增加一个dev指针,改改HEAD的指向,工作区的文件都没有任何变化
    不过,从现在开始,对工作区的修改和提交就是针对dev分支了,比如新提交一次后,dev指针往前移动一步,而master指针不变:


                master
                  ↓
    O——————O——————O——————O
                         ↑
                        dev
                         ↑
                        HEAD

    假如在dev的工作完成了,就可以把dev合并到master上.Git合并的方法,就是直接把master指向dev的当前提交,就完成了

                       master
                         ↓
    O——————O——————O======O
                         ↑
                        dev
                         ↑
                        HEAD
    合并完分之后,甚至可以删除dev分支.删除dev分支就是把dev指针给删除掉,删除后,我们就剩下一条master分支:
 
                        HEAD
                         ↓
                       master
                         ↓
    O——————O——————O——————O

    下面开始实战
    首先,创建dev分支,然后切换到dev分支:
    $ git checkout -b dev
    
    git checkout命令加上 -b 参数表示创建并切换,相当于以下两条命令:
    $ git branch dev
    $ git checkout dev

    然后使用$ git branch命令查看当前分支:
    $ git branch
    * dev
      master
    
    git branch会列出所有分支,当前分支前面会标一个*号
    然后,就可以在dev分支上正常提交,比如对readme.txt做个修改,加上一行:
    Creating a new branch is quick.

    然后提交:
    $ git add readme.txt
    $ git commit -m "branch test"
    [dev b17d20e] branch test
    1 file changed, 1 insertion(+)

    现在,dev分支的工作完成,我们就可以切换回master分支:
    $ git checkout master
    Switched to branch 'master'

    切换回master分支后,在查看一个readme.txt文件,刚才添加的内容不见了!因为那个提交是在dev分支上,而master分支此刻的提交点并没有变:
 
                 HEAD
                  ↓
                master
                  ↓
    O——————O——————O——————O
                         ↑
                        dev
    现在,我们把dev分支的工作合并到master分支上:
    $ git merge dev    
    Updating d46f35e..b17d20e
    Fast-forward
    readme.txt | 1 +
    1 file changed, 1 insertion(+) 

    git merge命令用于合并指定分支到当前分支,合并后,在查看readme.txt的内容,就可以看到,和dev分支的最新提交时完全一样的.
    注意到上面的Fast-forward信息,Git告诉我们,这次合并是'快进模式',也就是直接把master指向dev的当前提交,所以合并速度非常快,
    当然,也不是每次合并都能Fast-forward,后面会叫其他方式的合并.
    合并完成后,就可以放心删除dev分支了:
    $ git branch -d dev

    删除后,查看branch,就只剩下master分支了:
    $ git branch
    * master 
    因为创建、合并和删除分支非常快,所以Git鼓励你使用分支完成某个人物,合并后在删除分支,这和直接在master分支上工作效果是一样的,但过程更安全

    小结
        Git鼓励大量使用分支:
        查看分支:git branch
        创建分支:git branch [name]                    
        切换分支:git checkout [name]
        创建+切换分支:git checkout -b [name]
        合并某分支到当前分支:git merge [name]
        删除分支:git branch -d [name]

解决冲突
    合并分支往往也不是一帆风顺的.
    准备新的feature1分支,继续新的分支开发
    $ git checkout -b feature1 

    修改readme.txt最后一样,改为:
    Creating a new branch is quick AND simple

    在feature1分支上提交:
    $ git add readme.txt
    $ git commit -m "AND simple"

    切换到master分支
    $ git checkout master
    Switched to branch 'master'
    Your branch is ahead of 'origin/master' by 1 commit.
    (use "git push" to publish your local commits)

    Git还会自动提示我们当前master分支比远程master分支超前一个提交
    在master分支上把readme.txt文件的最后一行改为:
    creating a new branch is quick & simple

    提交
    $ git add readme.txt
    $ git commit -m "& simple"

    现在,master分支和feature1分支各自都分别有新的提交,变成了这样

                        HEAD
                         ↓
                       master
                         ↓
    O——————O——————O——————O
                  |______O     
                         ↑
                      feature1
    
    这种情况下,Git无法执行'快速合并',只能试图把各自的修改合并起来,但是这种合并很可能会有冲突
    $ git merge feature1
    Auto-merging readme.txt
    CONFLICT (content): Merge conflict in readme.txt
    Automatic merge failed; fix conflicts and then commit the result.

    Git告诉我们,readme.txt文件存在冲突,必须手动解决冲突后在提交,git status也可以告诉我们冲突的文件
    $ git status
    On branch master
    Your branch is ahead of 'origin/master' by 2 commits.
    (use "git push" to publish your local commits)

    You have unmerged paths.
    (fix conflicts and run "git commit")
    (use "git merge --abort" to abort the merge)

    Unmerged paths:
    (use "git add <file>..." to mark resolution)

        both modified:   readme.txt

    no changes added to commit (use "git add" and/or "git commit -a")

    我们可以直接查看readme.txt的内容
    $ cat readme.txt
    Git is a distributed version control system.
    Git is free software distributed under the GPL.
    Git has a mutable index called stage.
    Git tracks changes of files.
    <<<<<<< HEAD
    Creating a new branch is quick & simple.
    =======
    Creating a new branch is quick AND simple.
    >>>>>>> feature1

    Git用<<<<<<<,=======,>>>>>>>标记出不同分支的内容,我们修改如下后保存
    Creating a new branch is quick and simple

    再提交:
    $ git add readme.txt
    $ git commit -m "conflict fixed"

    现在,master分支和feature1变成了下图所示:
                               HEAD
                                ↓
                              master
                                ↓
    O——————O——————O——————O——————O
                  |______O______|        
                         ↑
                      feature1
    用带参数的git log也可以看到分支的合并情况:
    $ git log --graph --pretty=oneline --abbrev-commit

    最后删除feature1分支
    $ git branch -d feature1

    小结
        当Git无法自动合并分支时,就必须首先解决冲突.解决冲突后,在提交,合并完成.
        解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容,再提交
        用git log --graph命令可以看到分支合并图
        











