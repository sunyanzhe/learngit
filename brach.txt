分支管理
    分支就是科幻电影里面的平行宇宙,当你正在电脑前努力学习Git的时候,另一个你正在另一个平行宇宙里努力学习SVN.
    如果两个平行宇宙互不干扰,那对现在的你也没啥影响,不过,在某个时间点,两个平行宇宙合并了,结果,你既学会了Git又学会了SVN
    分支在实际中有什么用呢?假设你准备开发一个新功能,但是需要两周才能完成,第一周你写了50%的代码,如果立刻提交,由于代码还没写完,并不完整的代码库会导致别人不能干活了,如果等待吗全部写完再一次性提交,又存在丢失每天进度的巨大风险.
    现在有了分支,就不用怕了.你创建了一个属于你自己的分支,别人看不到,还继续在原来的分支上正常工作,而你在自己的分支上干活,想提交就提交,直到开发完毕后,再一次行合并到原来的分支上,这样,既安全,又不影响别人工作.
    其他版本控制系统如SVN等都有分支管理,但是用过之后你会发现,这些版本控制系统创建和切换分支比蜗牛还慢,简直让人无法忍受,结果分支功能成了摆设,大家都不去用
    但Git分支时与众不同的,无论创建、切换和删除分支,Git在1秒钟之内都能完成!无论你的版本库是1个文件还是1万个文件

创建与合并分支
    每次提交,Git都把他们串成一条时间线,这条时间线就是一个分支,截止到目前,只有一条时间线,在Git里,这个分支叫做主分支,即master分支.
    HEAD延更来说不是指向提交,而是指向master,master才是指向提交的,所以,HEAD指向的就是当前分支

    一开始的时候,master分支时一条线,Git用master指向最新的提交,再用HEAD指向master,就能确定当前分支,以及当前分支的提交点:

          HEAD
           ↓
         master
           ↓
    O——————O

    每次提交,master分支都会向前移动一步,这样,随着你不断提交,master分支的线也越来越长

                 HEAD
                  ↓
                master
                  ↓
    O——————O——————O

    当我们创建新的分支,例如dev时,Git新建了一个指针叫dev,指向master相同的提交,再把HEAD指向dev,就表示当前分支在dev上:
                 
                master
                  ↓
    O——————O——————O
                  ↑
                 dev
                  ↑
                 HEAD
    
    Git创建一个分支很快,因为除了增加一个dev指针,改改HEAD的指向,工作区的文件都没有任何变化
    不过,从现在开始,对工作区的修改和提交就是针对dev分支了,比如新提交一次后,dev指针往前移动一步,而master指针不变:


                master
                  ↓
    O——————O——————O——————O
                         ↑
                        dev
                         ↑
                        HEAD

    假如在dev的工作完成了,就可以把dev合并到master上.Git合并的方法,就是直接把master指向dev的当前提交,就完成了

                       master
                         ↓
    O——————O——————O======O
                         ↑
                        dev
                         ↑
                        HEAD
    合并完分之后,甚至可以删除dev分支.删除dev分支就是把dev指针给删除掉,删除后,我们就剩下一条master分支:
 
                        HEAD
                         ↓
                       master
                         ↓
    O——————O——————O——————O

    下面开始实战
    首先,创建dev分支,然后切换到dev分支:
    $ git checkout -b dev
    
    git checkout命令加上 -b 参数表示创建并切换,相当于以下两条命令:
    $ git branch dev
    $ git checkout dev

    然后使用$ git branch命令查看当前分支:
    $ git branch
    * dev
      master
    
    git branch会列出所有分支,当前分支前面会标一个*号
    然后,就可以在dev分支上正常提交,比如对readme.txt做个修改,加上一行:
    Creating a new branch is quick.

    然后提交:
    $ git add readme.txt
    $ git commit -m "branch test"
    [dev b17d20e] branch test
    1 file changed, 1 insertion(+)

    现在,dev分支的工作完成,我们就可以切换回master分支:
    $ git checkout master
    Switched to branch 'master'

    切换回master分支后,在查看一个readme.txt文件,刚才添加的内容不见了!因为那个提交是在dev分支上,而master分支此刻的提交点并没有变:
 
                 HEAD
                  ↓
                master
                  ↓
    O——————O——————O——————O
                         ↑
                        dev
    现在,我们把dev分支的工作合并到master分支上:
    $ git merge dev    
    Updating d46f35e..b17d20e
    Fast-forward
    readme.txt | 1 +
    1 file changed, 1 insertion(+) 

    git merge命令用于合并指定分支到当前分支,合并后,在查看readme.txt的内容,就可以看到,和dev分支的最新提交时完全一样的.
    注意到上面的Fast-forward信息,Git告诉我们,这次合并是'快进模式',也就是直接把master指向dev的当前提交,所以合并速度非常快,
    当然,也不是每次合并都能Fast-forward,后面会叫其他方式的合并.
    合并完成后,就可以放心删除dev分支了:
    $ git branch -d dev

    删除后,查看branch,就只剩下master分支了:
    $ git branch
    * master 
    因为创建、合并和删除分支非常快,所以Git鼓励你使用分支完成某个人物,合并后在删除分支,这和直接在master分支上工作效果是一样的,但过程更安全

    小结
        Git鼓励大量使用分支:
        查看分支:git branch
        创建分支:git branch [name]                    
        切换分支:git checkout [name]
        创建+切换分支:git checkout -b [name]
        合并某分支到当前分支:git merge [name]
        删除分支:git branch -d [name]

解决冲突
    合并分支往往也不是一帆风顺的.
    准备新的feature1分支,继续新的分支开发
    $ git checkout -b feature1 

    修改readme.txt最后一样,改为:
    Creating a new branch is quick AND simple

    在feature1分支上提交:
    $ git add readme.txt
    $ git commit -m "AND simple"

    切换到master分支
    $ git checkout master
    Switched to branch 'master'
    Your branch is ahead of 'origin/master' by 1 commit.
    (use "git push" to publish your local commits)

    Git还会自动提示我们当前master分支比远程master分支超前一个提交
    在master分支上把readme.txt文件的最后一行改为:
    creating a new branch is quick & simple

    提交
    $ git add readme.txt
    $ git commit -m "& simple"

    现在,master分支和feature1分支各自都分别有新的提交,变成了这样

                        HEAD
                         ↓
                       master
                         ↓
    O——————O——————O——————O
                  |______O     
                         ↑
                      feature1
    
    这种情况下,Git无法执行'快速合并',只能试图把各自的修改合并起来,但是这种合并很可能会有冲突
    $ git merge feature1
    Auto-merging readme.txt
    CONFLICT (content): Merge conflict in readme.txt
    Automatic merge failed; fix conflicts and then commit the result.

    Git告诉我们,readme.txt文件存在冲突,必须手动解决冲突后在提交,git status也可以告诉我们冲突的文件
    $ git status
    On branch master
    Your branch is ahead of 'origin/master' by 2 commits.
    (use "git push" to publish your local commits)

    You have unmerged paths.
    (fix conflicts and run "git commit")
    (use "git merge --abort" to abort the merge)

    Unmerged paths:
    (use "git add <file>..." to mark resolution)

        both modified:   readme.txt

    no changes added to commit (use "git add" and/or "git commit -a")

    我们可以直接查看readme.txt的内容
    $ cat readme.txt
    Git is a distributed version control system.
    Git is free software distributed under the GPL.
    Git has a mutable index called stage.
    Git tracks changes of files.
    <<<<<<< HEAD
    Creating a new branch is quick & simple.
    =======
    Creating a new branch is quick AND simple.
    >>>>>>> feature1

    Git用<<<<<<<,=======,>>>>>>>标记出不同分支的内容,我们修改如下后保存
    Creating a new branch is quick and simple

    再提交:
    $ git add readme.txt
    $ git commit -m "conflict fixed"

    现在,master分支和feature1变成了下图所示:
                               HEAD
                                ↓
                              master
                                ↓
    O——————O——————O——————O——————O
                  |______O______|        
                         ↑
                      feature1
    用带参数的git log也可以看到分支的合并情况:
    $ git log --graph --pretty=oneline --abbrev-commit

    最后删除feature1分支
    $ git branch -d feature1

    小结
        当Git无法自动合并分支时,就必须首先解决冲突.解决冲突后,在提交,合并完成.
        解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容,再提交
        用git log --graph命令可以看到分支合并图

分支管理策略
    通常,合并分支时,如果可能,Git会用Fast forward模式,但这种模式下,删除分支后,会丢掉分支信息
    如果要强制禁用Fast forward模式,Git就会在merge时生成一个新的commit,这样,从分支历史上就可以看出分支信息
    下面来实战一下--no-ff方式的git merge:
    首先,仍然创建并切换dev分支
    $ git checkout -b dev

    修改readme.txt文件,并提交一个新的commit:
    $ git add readme.txt
    $ git commit -m "add merge"

    现在,切换回master:
    $ git checkout master
    
    准备合并dev分支,注意--no-ff参数,表示禁用Fast-forward:
    $ git merge --no-ff -m "merge with no-ff" dev

    因为本次哼要创建一个新的commit,所以加上-m参数,把commit描述写进去
    合并后,我们用 $ git log看看分支历史:
    $ git log --graph -pretty=oneline -abbrev-commit
    *   9b5a577 (HEAD -> master) marge with no-ff
    |\
    | * 469a355 (dev) add merge
    |/


    可以看到,不使用Fast forward模式,merge后就像这样

                               HEAD
                                ↓
                              master
                                ↓
    O——————O——————O——————O——————O
                  |______O______|        
                         ↑
                        dev
  分支策略
    在实际开发中,我们应该按照几个基本原则进行分支管理:
    1.首先,master分支应该是非常稳定的,也就是引用来发布新版本,平时不能在上面干活;
    2.干活都在dev分支上,也就是说,dev分支是不稳定的,到某个时候,比如1.0版本发布时,在把dev分支合并到master上,在master分支发布1.0版本;
    3.你和你的小伙伴们每个人都在dev分支上干活,每个人都有自己的分支,时不时地往dev分支上合并就可以了
    所以,团队合作的分支看起来就像这样:
    
    O————————————O———————————O-------master
     \           |           |
      O———————O——O——————O————O————O-----dev
      |\       /|          /|
      | O——O———O——————O————O————O--------michael
      |         |           |
       \        |           |
         O——O———O————O——————O————O-----bob

      小结
        Git分支十分强大,在团队开发中应该充分应用
        合并分支时,加上--no-ff参数可以用普通模式合并,合并后的历史有分支,能看出来曾经做过合并,而Fast forward合并就看不出来曾经做过合并

Bug分支
  软件开发中,bug就像家常便饭一样,有了bug就需要修复,在Git中,由于分支时如此的强大,所以,每个bug都可以通过一个新的临时分支来修复,修复后,合并分支,然后将临时分支删除
  当你接到一个修复一个代码101的bug的任务时,很自然地,你想创建一个分支issue-101来修复它,但是,等等,当前正在dev上进行的工作还没有提交
  $ git status
  On branch dev
  Changes to be committed:
    (use "git reset HEAD <file>..." to unstage)

      new file:   hello.py

  Changes not staged for commit:
    (use "git add <file>..." to update what will be committed)
    (use "git checkout -- <file>..." to discard changes in working directory)

      modified:   readme.txt
  并不是你不想提交,而是工作只进行到一般,还没发提交,预计完成还需要1天时间.但是,必须在两个小时内修复该bug,怎么办?
  型号,Git还提供了一个stash功能,可以把当前工作现场'储藏'起来,等以后恢复现场后继续工作:
    $ git stash
    Saved working directory and index state WIP on dev: f52c633 add merge

  现在,用$ git status查看工作区,就是干净的(除非有没有被Git管理的文件),因此可以放心地创建分支来修复bug
  首先确定要在哪个分支上修复bug,假定需要在master分支上修复,就从master创建临时分支
    $ git checkout master
    Switched to branch 'master'
    Your branch is ahead of 'origin/master' by 6 commits.
      (use "git push" to publish your local commits)

    $ git checkout -b issue-101
    Switched to a new branch 'issue-101'

  现在修复bug,需要把'Git is free software...'改为'Git is a free software...',然后提交:
    $ add readme.txt
    $ git commit -m 'fix bug 101'

  修复完成后,切换到master分支,并完成合并,最后删除issue-101分支
    $ git checkout master
    $ git merge --no-ff -m "merged bug fix 101" issue-101
  
  太棒了,原计划两个小时的bug修复只花了5分钟!现在,是时候接着回到dev分支干活了
    $ git checkout dev
    Switched to branch 'dev'

    $ git status
    On branch dev
    nothing to commit, working tree clean

    工作区是干净的,刚才的工作现场存到哪里去了?用git stash list命令看看:
    $ git stash list
    stash@{0}: WIP on dev: f52c633 add merge

    工作现场还在,Git把stash内容存在某个地方了,但是需要修复一下,有两个办法:
    一是用git stash apply恢复,但恢复后,stash内容并不删除,你需要用git stash drop来删除;
    另一种方式是用git stash pop,恢复的同时把stash内容也删了:
    $ git stash pop
    On branch dev
    Changes to be committed:
      (use "git reset HEAD <file>..." to unstage)

        new file:   hello.py

    Changes not staged for commit:
      (use "git add <file>..." to update what will be committed)
      (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   readme.txt

    Dropped refs/stash@{0} (5d677e2ee266f39ea296182fb2354265b91b3b2a)
 
  再用$ git stash list查看就看不到任何stash内容了 
    $ git stash list
  
  你可以多次stash,恢复的时候,先用git stash list查看,然后恢复指定的stash,用命令:
  $ git stash applyu stash@{0}

  小结
    修复bug时,我们会通过创建新的bug分支进行修复,然后合并,最后删除;
    当手头工作没有完成时,先把工作现场git stash pop,回到工作现场

Feature分支
  软件开发中,总有无穷无尽的新功能要不断添加进来.
  添加一个心功能室,你肯定不希望因为一些实验性质的代码,把主分支搞乱了,所以,每添加一个新功能,最好新建一个feature分支,在上面开发,完成后,合并,最后,删除该feature分支

  现在接到了一个新的任务:开发代号为Vulcan的新功能
  准备开发:
  $ git checkout -b feature-vulcan
  
  开发完成后:
  $ git add vulcan.py
  $ git status
  $ git commit -m "add feature vulcan"

  切回master,准备合并:
  $ git checkout master
  
  一切顺利的话,feature分支和bug分支时类似的,合并,然后删除
  但是,接到命令,新功能必须取消,这个包含机密资料的分支必须就地销毁:
  $ git branch -d feature-vulcan
  error: The branch 'feature-vulcan' is not fully merged
  If you are sure you want to delete it, run 'git branch -D feature-vulcan'.

  销毁失败.Git友情提示,feature-vulcan分支还没有被合并,如果删除,将丢失掉修改,如果要强行删除,需要使用大写的-D参数..
  现在我们强行删除:
  $ git branch -D feature-vulcan
  Deleted branch feature-vulcan (was 287773e)

  终于删除成功





